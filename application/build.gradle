// root build.gradle
def sysProps = System.properties
def name = 'com.pearson.projectone'
def appVersion = sysProps["APP_VERSION"] ?: "1.0.0-SNAPSHOT"
def bootVersion = "1.4.2.RELEASE"
def getProfile = {
	def providedProfile = System.getenv('P1_ENV')
	def environment = 'dev';
	if (providedProfile) {

		switch (providedProfile) {
			case 'prod':
			case 'production':
				environment = 'prod'
				break

			case 'beta':
			case 'beta1':
				environment = 'beta1'
				break

			case 'ppe':
				environment = 'ppe'
				break

			case 'staging':
				environment = 'staging'
				break

			case 'test':
			case 'testing':
				environment = 'tst'
				break

			case 'devqa':
				environment = 'devqa'
				break

			case 'qa':
				environment = 'qa'
				break;
		}
	}
	environment.trim()
}

ext.versions = [
		groovy           : "2.4.7",
		joda             : "2.9.4",
		mysql            : "5.1.39",
		hsql             : "2.3.3",
		boot             : bootVersion,
		aws_sdk          : "1.11.64",
		aws_sqs_msg      : "1.0.0",
		apache_httpcore  : "4.3.3",
		apache_httpclient: "4.3.6",
		commons_io       : "2.4",
		commons_logging  : "1.2",
		powermock        : "1.6.4",
		swagger          : "2.6.1",
		modelmapper      : "0.7.7",
		querydsl         : "4.0.8",
		profile          : getProfile()
]

buildscript {

	ext {
		bootVersion = "1.4.2.RELEASE"
	}
	repositories {
		jcenter()
		maven { url "http://repo.spring.io/snapshot" }
		maven { url "http://repo.spring.io/milestone" }
	}

	dependencies {
		classpath("org.springframework.boot:spring-boot-gradle-plugin:${bootVersion}")
		classpath("org.springframework:springloaded:1.2.5.RELEASE")
		classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:2.2.1"
	}
}

apply plugin: 'idea'



repositories {
	jcenter()
	maven { url "http://repo.spring.io/snapshot" }
	maven { url "http://repo.spring.io/milestone" }
}

allprojects {

	apply plugin: 'idea'
	group = "${name}"
	version = "${appVersion}"


	repositories {
		jcenter()
		maven { url "http://repo.spring.io/snapshot" }
		maven { url "http://repo.spring.io/milestone" }
		mavenCentral()
	}

}

subprojects {

	apply plugin: 'java'
	apply plugin: 'groovy'
	apply plugin: 'org.sonarqube'
	apply plugin: 'jacoco'

	dependencies {
		compile("org.codehaus.groovy:groovy-all:${versions.groovy}")
		// for joda date time in JPA entities
		compile("joda-time:joda-time:${versions.joda}")
		compile("mysql:mysql-connector-java:${versions.mysql}")
		compile("org.hsqldb:hsqldb:${versions.hsql}")
		compile 'org.apache.commons:commons-lang3:3.4'
		compile("org.springframework.boot:spring-boot-starter-data-jpa:${versions.boot}")

		testCompile("org.springframework.boot:spring-boot-starter-test:${versions.boot}")
		testCompile 'org.spockframework:spock-spring:1.0-groovy-2.4'
		testCompile("org.powermock:powermock-mockito-release-full:${versions.powermock}")
		testCompile("org.powermock:powermock-module-junit4:${versions.powermock}")
		testCompile("org.powermock:powermock-module-junit4-rule:${versions.powermock}")
		testCompile("org.powermock:powermock-classloading-xstream:${versions.powermock}")
		testCompile 'cglib:cglib-nodep:3.2.2'

	}

	tasks.withType(JavaCompile) {
		options.incremental = true
	}

	sourceSets {

		main {
			java {
				srcDirs = ['src/main/java', 'src/main/generated/java']
			}
		}
		test {
			java.srcDirs = ['src/test/unit/java']
			groovy.srcDirs = ['src/test/unit/groovy']
		}
		integration {
			java.srcDirs = ['src/test/integration/java']
			groovy.srcDirs = ['src/test/integration/groovy']
			resources.srcDir 'src/test/integration/resources'
			compileClasspath += main.output + test.output
			runtimeClasspath += main.output + test.output
		}
	}

	configurations {
		integrationCompile.extendsFrom testCompile
		integrationRuntime.extendsFrom testRuntime
	}

	task integration(type: Test, description: 'Runs the integration tests.', group: 'Verification') {
		testClassesDir = sourceSets.integration.output.classesDir
		classpath = sourceSets.integration.runtimeClasspath
		include '**/*Spec.*'
		systemProperty 'spring.profiles.active', 'integration'
		outputs.upToDateWhen { false }
		jacoco {
			destinationFile = file("$buildDir/jacoco/jacocoIntegTest.exec")
		}
	}

	def ANSI_RESET = "\u001B[0m"
	def ANSI_RED = "\u001B[31m"
	def ANSI_GREEN = "\u001B[32m"
	test {
		afterTest { desc, result ->
			println "${ANSI_RESET} [UNIT][${project.name}]: ${desc.className}.[${desc.name}] with result: " +
					"${result.resultType.toString() == 'SUCCESS' ? ANSI_GREEN : ANSI_RED} ${result.resultType} ${ANSI_RESET}"
		}
		jacoco {
			destinationFile = file("$buildDir/jacoco/jacocoTest.exec")
		}
	}
	integration {
		afterTest { desc, result ->
			println "${ANSI_RESET} [INTEGRATION][${project.name}]: ${desc.className}.[${desc.name}] with result: " +
					"${result.resultType.toString() == 'SUCCESS' ? ANSI_GREEN : ANSI_RED} ${result.resultType} ${ANSI_RESET}"
		}
	}
	sonarqube {
		properties {
			property "sonar.jacoco.reportPath", "$buildDir/jacoco/jacocoTest.exec"
			property "sonar.jacoco.itReportPath", "$buildDir/jacoco/jacocoIntegTest.exec"
		}
	}
}

// gradle wrapper
task wrapper(type: Wrapper) {
	gradleVersion = '3.1'
}

// this is to bake the profile right into the war
gradle.taskGraph.beforeTask { Task task ->
	def profile = getProfile()

	switch (task.name) {
		case "war":
			// we almost never want to create a war with dev
			// if so, we set it to prod ( this follows grails war which by default uses prod to war up )
			if (profile == 'dev') {
				profile = 'prod'
			}
			println "@@@@ explicit SPRING profile = ${profile} with project ${task.project.name} "
			def basePath = task.project.buildDir
			def applicationYml = file("${basePath}/resources/main/config/application.yml").text
			applicationYml = applicationYml.replaceAll("active: dev", "active: ${profile}")
			file("${basePath}/resources/main/config/application.yml").write(applicationYml)
			break
	}

}
